<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Library</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;500&family=IBM+Plex+Sans:wght@300;400;500;600&display=swap");

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      :root {
        --bg: #0a0a0a;
        --bg-raised: #111111;
        --bg-hover: #1a1a1a;
        --bg-active: #1e1e1e;
        --border: #222;
        --border-light: #2a2a2a;
        --text: #c8c8c8;
        --text-dim: #666;
        --text-bright: #e8e8e8;
        --accent: #e96401;
        --accent-dim: #a55518;
        --mono: "IBM Plex Mono", monospace;
        --sans: "IBM Plex Sans", sans-serif;
        --row-h: 34px;
      }

      html,
      body {
        height: 100%;
        overflow: hidden;
      }

      body {
        background: var(--bg);
        color: var(--text);
        font-family: var(--sans);
        font-size: 13px;
        display: flex;
      }

      /* ── Sidebar ── */
      #sidebar {
        width: 280px;
        min-width: 280px;
        height: 100vh;
        border-right: 1px solid var(--border);
        display: flex;
        flex-direction: column;
        background: var(--bg);
      }

      #sidebar-header {
        padding: 16px 14px 10px;
        border-bottom: 1px solid var(--border);
      }

      #sidebar-header h1 {
        font-family: var(--mono);
        font-size: 11px;
        font-weight: 500;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--text-dim);
        margin-bottom: 10px;
      }

      #sidebar-search {
        width: 100%;
        background: var(--bg-raised);
        border: 1px solid var(--border);
        color: var(--text);
        font-family: var(--mono);
        font-size: 12px;
        padding: 7px 10px;
        outline: none;
        transition: border-color 0.15s;
      }

      #sidebar-search::placeholder {
        color: var(--text-dim);
      }
      #sidebar-search:focus {
        border-color: var(--accent-dim);
      }

      #playlist-list {
        flex: 1;
        overflow-y: auto;
        scrollbar-width: thin;
        scrollbar-color: var(--border-light) transparent;
      }

      .sidebar-item {
        display: flex;
        align-items: center;
        padding: 8px 14px;
        cursor: pointer;
        border-bottom: 1px solid var(--border);
        transition: background 0.1s;
        gap: 8px;
      }

      .sidebar-item:hover {
        background: var(--bg-hover);
      }
      .sidebar-item.active {
        background: var(--bg-active);
        border-left: 2px solid var(--accent);
        padding-left: 12px;
      }

      .sidebar-item-name {
        flex: 1;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 13px;
      }

      .sidebar-item-count {
        font-family: var(--mono);
        font-size: 11px;
        color: var(--text-dim);
        flex-shrink: 0;
      }

      .sidebar-item-date {
        font-family: var(--mono);
        font-size: 10px;
        color: var(--text-dim);
        flex-shrink: 0;
      }

      .sidebar-section {
        padding: 10px 14px 4px;
        font-family: var(--mono);
        font-size: 10px;
        font-weight: 500;
        letter-spacing: 0.1em;
        text-transform: uppercase;
        color: var(--text-dim);
        border-bottom: 1px solid var(--border);
        position: sticky;
        top: 0;
        background: var(--bg);
        z-index: 1;
      }

      /* ── Main ── */
      #main {
        flex: 1;
        display: flex;
        flex-direction: column;
        height: 100vh;
        min-width: 0;
      }

      #main-header {
        padding: 16px 20px 10px;
        border-bottom: 1px solid var(--border);
        display: flex;
        align-items: flex-end;
        gap: 12px;
        flex-shrink: 0;
      }

      #back-btn {
        background: none;
        border: 1px solid var(--border);
        color: var(--text-dim);
        font-family: var(--mono);
        font-size: 12px;
        padding: 3px 10px;
        cursor: pointer;
        display: none;
        margin-bottom: 1px;
        flex-shrink: 0;
      }

      #back-btn:hover {
        color: var(--text);
        border-color: var(--border-light);
      }

      #main-title {
        font-family: var(--sans);
        font-size: 22px;
        font-weight: 600;
        color: var(--text-bright);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      #main-meta {
        font-family: var(--mono);
        font-size: 11px;
        color: var(--text-dim);
        white-space: nowrap;
        padding-bottom: 3px;
      }

      #track-filter-wrap {
        padding: 8px 20px;
        border-bottom: 1px solid var(--border);
        flex-shrink: 0;
        display: flex;
        align-items: center;
        gap: 14px;
      }

      #dedup-label {
        display: none;
        align-items: center;
        gap: 5px;
        font-family: var(--mono);
        font-size: 11px;
        color: var(--text-dim);
        cursor: pointer;
        white-space: nowrap;
        user-select: none;
      }

      #dedup-label:hover {
        color: var(--text);
      }

      #dedup-toggle {
        accent-color: var(--accent);
        cursor: pointer;
      }

      #track-filter {
        width: 100%;
        max-width: 360px;
        background: var(--bg-raised);
        border: 1px solid var(--border);
        color: var(--text);
        font-family: var(--mono);
        font-size: 12px;
        padding: 6px 10px;
        outline: none;
        transition: border-color 0.15s;
      }

      #track-filter::placeholder {
        color: var(--text-dim);
      }
      #track-filter:focus {
        border-color: var(--accent-dim);
      }

      /* ── Column Header ── */
      #col-header {
        display: flex;
        padding: 6px 20px;
        border-bottom: 1px solid var(--border);
        font-family: var(--mono);
        font-size: 10px;
        font-weight: 500;
        letter-spacing: 0.08em;
        text-transform: uppercase;
        color: var(--text-dim);
        flex-shrink: 0;
        cursor: default;
        user-select: none;
      }

      #col-header span {
        padding: 2px 0;
        cursor: pointer;
      }
      #col-header span:hover {
        color: var(--text);
      }
      #col-header span.sorted {
        color: var(--accent);
      }
      #col-header span.sorted::after {
        content: " ▲";
        font-size: 8px;
      }
      #col-header span.sorted.desc::after {
        content: " ▼";
        font-size: 8px;
      }
      #col-header .col-num {
        cursor: default;
      }
      #col-header .col-num:hover {
        color: var(--text-dim);
      }
      .col-num {
        width: 44px;
        text-align: right;
        padding-right: 14px !important;
        flex-shrink: 0;
      }
      .col-track {
        flex: 4;
        min-width: 0;
      }
      .col-artist {
        flex: 3;
        min-width: 0;
      }
      .col-album {
        flex: 3;
        min-width: 0;
      }
      .col-date {
        width: 90px;
        text-align: right;
        flex-shrink: 0;
      }

      /* ── Track List (virtual scroll) ── */
      #track-viewport {
        flex: 1;
        overflow-y: auto;
        position: relative;
        scrollbar-width: thin;
        scrollbar-color: var(--border-light) transparent;
      }

      #track-runway {
        position: relative;
      }

      .track-row {
        display: flex;
        align-items: center;
        padding: 0 20px;
        height: var(--row-h);
        position: absolute;
        left: 0;
        right: 0;
        border-bottom: 1px solid var(--border);
        transition: background 0.08s;
      }

      .track-row:hover {
        background: var(--bg-hover);
      }

      .track-row span {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }

      .track-row .col-num {
        font-family: var(--mono);
        font-size: 11px;
        color: var(--text-dim);
      }

      .track-row .col-track a {
        color: var(--text-bright);
        text-decoration: none;
      }

      .track-row .col-track a:hover {
        color: var(--accent);
        text-decoration: underline;
      }

      .track-row .col-track .local-track {
        color: var(--text-dim);
        font-style: italic;
      }

      .track-row .col-artist {
        color: var(--text);
        cursor: pointer;
      }
      .track-row .col-artist:hover {
        color: var(--accent);
      }
      .col-source {
        flex: 2;
        min-width: 0;
      }
      .track-row .col-source {
        color: var(--text-dim);
        font-size: 12px;
      }
      .track-row .col-album {
        color: var(--text-dim);
        cursor: pointer;
      }
      .track-row .col-album:hover {
        color: var(--accent);
      }

      .track-row .col-date {
        font-family: var(--mono);
        font-size: 11px;
        color: var(--text-dim);
      }

      /* ── Empty state ── */
      #empty-state {
        display: flex;
        align-items: center;
        justify-content: center;
        flex: 1;
        color: var(--text-dim);
        font-family: var(--mono);
        font-size: 12px;
      }

      /* ── Loading ── */
      #loading {
        display: flex;
        align-items: center;
        justify-content: center;
        height: 100vh;
        width: 100%;
        font-family: var(--mono);
        font-size: 12px;
        color: var(--text-dim);
      }

      #loading.hidden {
        display: none;
      }

      /* ── Scrollbar (webkit) ── */
      ::-webkit-scrollbar {
        width: 6px;
      }
      ::-webkit-scrollbar-track {
        background: transparent;
      }
      ::-webkit-scrollbar-thumb {
        background: var(--border-light);
        border-radius: 3px;
      }
      ::-webkit-scrollbar-thumb:hover {
        background: #333;
      }

      /* ── Upload Screen ── */
      #upload-screen {
        display: none;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        height: 100vh;
        width: 100%;
        gap: 20px;
      }

      #upload-screen h1 {
        font-family: var(--sans);
        font-size: 24px;
        font-weight: 600;
        color: var(--text-bright);
      }

      #upload-screen p {
        font-family: var(--mono);
        font-size: 12px;
        color: var(--text-dim);
        max-width: 400px;
        text-align: center;
        line-height: 1.6;
      }

      #upload-screen a {
        color: var(--accent);
      }

      #drop-zone {
        width: 400px;
        height: 180px;
        border: 2px dashed var(--border-light);
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 12px;
        cursor: pointer;
        transition:
          border-color 0.15s,
          background 0.15s;
        font-family: var(--mono);
        font-size: 12px;
        color: var(--text-dim);
      }

      #drop-zone:hover,
      #drop-zone.dragover {
        border-color: var(--accent);
        background: var(--bg-raised);
      }

      #drop-zone .hint {
        font-size: 10px;
        color: var(--text-dim);
      }

      #upload-error {
        font-family: var(--mono);
        font-size: 11px;
        color: #c44;
        display: none;
      }

      /* ── Stats bar ── */
      #stats-bar {
        padding: 6px 14px;
        font-family: var(--mono);
        font-size: 10px;
        color: var(--text-dim);
        border-top: 1px solid var(--border);
        display: flex;
        gap: 16px;
        flex-shrink: 0;
      }
    </style>
  </head>
  <body>
    <div id="loading">loading data...</div>

    <div id="upload-screen">
      <h1>Spotify Library Browser</h1>
      <p>
        Browse your exported Spotify data. Request yours from
        <a
          href="https://www.spotify.com/account/privacy/"
          target="_blank"
          rel="noopener"
          >spotify.com/account/privacy</a
        >
        then drop the files here.
      </p>
      <div id="drop-zone">
        <span>drop folder or files here</span>
        <span class="hint">or click to select JSON files</span>
        <input
          type="file"
          id="file-input"
          multiple
          accept=".json"
          style="display: none"
        />
      </div>
      <div id="upload-error"></div>
      <p>Your data never leaves your browser.</p>
      <a href="https://github.com/danielhdzzz/spotify-data-view" target="_blank" rel="noopener" style="font-family:var(--mono);font-size:10px;color:var(--text-dim);text-decoration:none;margin-top:8px">github</a>
    </div>

    <div id="sidebar" style="display: none">
      <div id="sidebar-header">
        <h1>Library</h1>
        <input
          type="text"
          id="sidebar-search"
          placeholder="filter playlists..."
          spellcheck="false"
        />
      </div>
      <div id="playlist-list"></div>
      <div id="stats-bar">
        <span class="stats-text"></span>
        <a href="https://github.com/danielhdzzz/spotify-data-view" target="_blank" rel="noopener" style="color:var(--text-dim);text-decoration:none;margin-left:auto">github</a>
      </div>
    </div>

    <div id="main" style="display: none">
      <div id="main-header">
        <button id="back-btn">&larr; back</button>
        <div id="main-title">Select a playlist</div>
        <div id="main-meta"></div>
      </div>
      <div id="track-filter-wrap">
        <input
          type="text"
          id="track-filter"
          placeholder="filter tracks..."
          spellcheck="false"
        />
        <label id="dedup-label"
          ><input type="checkbox" id="dedup-toggle" />hide duplicates</label
        >
      </div>
      <div id="col-header">
        <span class="col-num">#</span>
        <span class="col-track">Title</span>
        <span class="col-artist">Artist</span>
        <span class="col-album">Album</span>
        <span class="col-source" style="display: none">Source</span>
        <span class="col-date">Added</span>
      </div>
      <div id="track-viewport">
        <div id="track-runway"></div>
      </div>
      <div id="empty-state" style="display: none">No tracks found</div>
    </div>

    <script>
      (function () {
        const ROW_H = 34;
        const RENDER_BUFFER = 10;

        let library = null;
        let playlists = [];
        let activeId = null;
        let currentTracks = [];
        let filteredTracks = [];
        let filterTimer = null;
        let sortCol = null; // 'name', 'artist', 'album', 'date', 'source'
        let sortAsc = true;
        let isDetailView = false; // artist or album detail (shows source column)
        let catalogMode = null; // 'artists' | 'albums' | null
        let artistIndex = []; // [{ name, count }] built at load
        let albumIndex = []; // [{ name, artist, count }] built at load
        let catalogItems = []; // current full catalog list
        let filteredCatalog = []; // filtered catalog list
        let navHistory = []; // stack of { type, id } for back navigation

        // ── DOM refs ──
        const $loading = document.getElementById("loading");
        const $sidebar = document.getElementById("sidebar");
        const $main = document.getElementById("main");
        const $playlistList = document.getElementById("playlist-list");
        const $sidebarSearch = document.getElementById("sidebar-search");
        const $mainTitle = document.getElementById("main-title");
        const $mainMeta = document.getElementById("main-meta");
        const $trackFilter = document.getElementById("track-filter");
        const $viewport = document.getElementById("track-viewport");
        const $runway = document.getElementById("track-runway");
        const $emptyState = document.getElementById("empty-state");
        const $colHeader = document.getElementById("col-header");
        const $trackFilterWrap = document.getElementById("track-filter-wrap");
        const $statsBar = document.getElementById("stats-bar");
        const $backBtn = document.getElementById("back-btn");
        const $dedupToggle = document.getElementById("dedup-toggle");
        const $dedupLabel = document.getElementById("dedup-label");
        const $uploadScreen = document.getElementById("upload-screen");
        const $dropZone = document.getElementById("drop-zone");
        const $fileInput = document.getElementById("file-input");
        const $uploadError = document.getElementById("upload-error");

        // ── Data Loading ──

        // Try fetching local data/ folder first; if it fails, show upload screen
        async function tryLocalData() {
          try {
            const res = await fetch("data/YourLibrary.json");
            if (!res.ok) throw new Error("not found");
            const libData = await res.json();

            // Detect how many Playlist files exist
            const playlistFiles = [];
            for (let i = 1; i <= 20; i++) {
              try {
                const pr = await fetch("data/Playlist" + i + ".json");
                if (!pr.ok) break;
                playlistFiles.push(await pr.json());
              } catch {
                break;
              }
            }

            processData(libData, playlistFiles);
          } catch {
            // No local data — show upload screen
            $loading.classList.add("hidden");
            $uploadScreen.style.display = "flex";
          }
        }

        // Process uploaded or fetched data
        function processData(libData, playlistFiles) {
          library = libData;

          const allPlaylists = [];
          for (const pf of playlistFiles) {
            if (pf.playlists) allPlaylists.push(...pf.playlists);
          }

          // Sort by last modified, newest first
          allPlaylists.sort((a, b) =>
            b.lastModifiedDate.localeCompare(a.lastModifiedDate),
          );

          playlists = allPlaylists.map((p, i) => ({
            id: "pl_" + i,
            name: p.name,
            date: p.lastModifiedDate,
            trackCount: p.items.length,
            tracks: normalizePlaylistTracks(p.items),
          }));

          // Build artist index
          const artistMap = new Map();
          for (const t of library.tracks) {
            const key = t.artist.toLowerCase();
            if (!artistMap.has(key))
              artistMap.set(key, { name: t.artist, count: 0 });
            artistMap.get(key).count++;
          }
          for (const pl of playlists) {
            for (const t of pl.tracks) {
              const key = t.artist.toLowerCase();
              if (!artistMap.has(key))
                artistMap.set(key, { name: t.artist, count: 0 });
              artistMap.get(key).count++;
            }
          }
          artistIndex = Array.from(artistMap.values()).sort(
            (a, b) => b.count - a.count,
          );

          // Build album index
          const albumMap = new Map();
          for (const t of library.tracks) {
            const key = (t.album + "|||" + t.artist).toLowerCase();
            if (!albumMap.has(key))
              albumMap.set(key, { name: t.album, artist: t.artist, count: 0 });
            albumMap.get(key).count++;
          }
          for (const pl of playlists) {
            for (const t of pl.tracks) {
              const key = (t.album + "|||" + t.artist).toLowerCase();
              if (!albumMap.has(key))
                albumMap.set(key, {
                  name: t.album,
                  artist: t.artist,
                  count: 0,
                });
              albumMap.get(key).count++;
            }
          }
          albumIndex = Array.from(albumMap.values()).sort(
            (a, b) => b.count - a.count,
          );

          const totalTracks =
            library.tracks.length +
            playlists.reduce((s, p) => s + p.trackCount, 0);
          const $statsText = $statsBar.querySelector('.stats-text');
          if ($statsText) $statsText.textContent = `${library.tracks.length} liked songs \u00b7 ${playlists.length} playlists \u00b7 ${totalTracks.toLocaleString()} total tracks`;

          $loading.classList.add("hidden");
          $uploadScreen.style.display = "none";
          $sidebar.style.display = "";
          $main.style.display = "";

          renderSidebar("");
        }

        // ── File Upload ──
        function showUploadError(msg) {
          $uploadError.textContent = msg;
          $uploadError.style.display = "";
        }

        function readFileAsJSON(file) {
          return new Promise((resolve) => {
            const reader = new FileReader();
            reader.onload = () => {
              try {
                resolve({ name: file.name, data: JSON.parse(reader.result) });
              } catch {
                resolve({ name: file.name, data: null });
              }
            };
            reader.onerror = () => resolve({ name: file.name, data: null });
            reader.readAsText(file);
          });
        }

        function processUploadedFiles(results) {
          const libFile = results.find((r) => r.name === "YourLibrary.json");
          if (!libFile || !libFile.data) {
            showUploadError(
              "YourLibrary.json not found. Make sure to include it in your selection.",
            );
            return;
          }

          const playlistFiles = results
            .filter((r) => /^Playlist\d+\.json$/i.test(r.name) && r.data)
            .map((r) => r.data);

          processData(libFile.data, playlistFiles);
        }

        // Read flat file list (from file picker or simple drop)
        function handleFiles(files) {
          $uploadError.style.display = "none";
          const jsonFiles = Array.from(files).filter((f) =>
            f.name.endsWith(".json"),
          );
          if (jsonFiles.length === 0) {
            showUploadError(
              "No JSON files found. Select the files from your Spotify data export.",
            );
            return;
          }
          Promise.all(jsonFiles.map(readFileAsJSON)).then(processUploadedFiles);
        }

        // Read entries from a dropped folder using the File System API
        function readEntries(dirReader) {
          return new Promise((resolve) => {
            const all = [];
            (function read() {
              dirReader.readEntries((entries) => {
                if (entries.length === 0) return resolve(all);
                all.push(...entries);
                read();
              });
            })();
          });
        }

        function entryToFile(entry) {
          return new Promise((resolve) => entry.file(resolve));
        }

        async function collectJSONFiles(entries) {
          const files = [];
          for (const entry of entries) {
            if (entry.isFile && entry.name.endsWith(".json")) {
              files.push(await entryToFile(entry));
            } else if (entry.isDirectory) {
              const subEntries = await readEntries(entry.createReader());
              files.push(...(await collectJSONFiles(subEntries)));
            }
          }
          return files;
        }

        $dropZone.addEventListener("click", () => $fileInput.click());
        $fileInput.addEventListener("change", (e) =>
          handleFiles(e.target.files),
        );

        $dropZone.addEventListener("dragover", (e) => {
          e.preventDefault();
          $dropZone.classList.add("dragover");
        });
        $dropZone.addEventListener("dragleave", () =>
          $dropZone.classList.remove("dragover"),
        );

        $dropZone.addEventListener("drop", async (e) => {
          e.preventDefault();
          $dropZone.classList.remove("dragover");
          $uploadError.style.display = "none";

          // Try the DataTransfer items API first (supports folders)
          const items = e.dataTransfer.items;
          if (items && items.length > 0 && items[0].webkitGetAsEntry) {
            const entries = [];
            for (let i = 0; i < items.length; i++) {
              const entry = items[i].webkitGetAsEntry();
              if (entry) entries.push(entry);
            }
            const files = await collectJSONFiles(entries);
            if (files.length === 0) {
              showUploadError(
                "No JSON files found. Drop your Spotify data folder or select the JSON files inside it.",
              );
              return;
            }
            Promise.all(files.map(readFileAsJSON)).then(processUploadedFiles);
          } else {
            // Fallback: flat file list
            handleFiles(e.dataTransfer.files);
          }
        });

        function normalizePlaylistTracks(items) {
          return items
            .map((item) => {
              if (item.track) {
                return {
                  name: item.track.trackName,
                  artist: item.track.artistName,
                  album: item.track.albumName,
                  uri: item.track.trackUri,
                  date: item.addedDate || "",
                  local: false,
                };
              }
              if (item.localTrack) {
                // Parse local URI: spotify:local:Artist:Album:Track:Duration
                const parts = item.localTrack.uri
                  .replace("spotify:local:", "")
                  .split(":");
                return {
                  name: decodeURIComponent(parts[2] || "Unknown"),
                  artist: decodeURIComponent(parts[0] || "Unknown"),
                  album: decodeURIComponent(parts[1] || ""),
                  uri: null,
                  date: item.addedDate || "",
                  local: true,
                };
              }
              return null;
            })
            .filter(Boolean);
        }

        function normalizeLibraryTracks(tracks) {
          return tracks.map((t) => ({
            name: t.track,
            artist: t.artist,
            album: t.album,
            uri: t.uri,
            date: "",
            local: false,
          }));
        }

        // ── Sidebar ──
        function renderSidebar(filter) {
          const frag = document.createDocumentFragment();
          const q = filter.toLowerCase();

          // Liked Songs (always show unless filtered out)
          if (!q || "liked songs".includes(q)) {
            const likedItem = makeSidebarItem(
              "liked",
              "Liked Songs",
              library.tracks.length,
              "",
            );
            frag.appendChild(likedItem);
          }

          // Artists
          if (!q || "artists".includes(q)) {
            frag.appendChild(
              makeSidebarItem("artists", "Artists", artistIndex.length, ""),
            );
          }

          // Albums
          if (!q || "albums".includes(q)) {
            frag.appendChild(
              makeSidebarItem("albums", "Albums", albumIndex.length, ""),
            );
          }

          // Section label
          const sectionEl = document.createElement("div");
          sectionEl.className = "sidebar-section";
          sectionEl.textContent = "Playlists";
          frag.appendChild(sectionEl);

          // Playlists
          let count = 0;
          for (const p of playlists) {
            if (q && !p.name.toLowerCase().includes(q)) continue;
            frag.appendChild(
              makeSidebarItem(p.id, p.name, p.trackCount, p.date),
            );
            count++;
          }

          $playlistList.innerHTML = "";
          $playlistList.appendChild(frag);

          // Restore active state
          if (activeId) {
            const el = $playlistList.querySelector(`[data-id="${activeId}"]`);
            if (el) el.classList.add("active");
          }
        }

        function makeSidebarItem(id, name, count, date) {
          const el = document.createElement("div");
          el.className = "sidebar-item";
          if (id === activeId) el.classList.add("active");
          el.dataset.id = id;

          const nameSpan = document.createElement("span");
          nameSpan.className = "sidebar-item-name";
          nameSpan.textContent = name;

          const countSpan = document.createElement("span");
          countSpan.className = "sidebar-item-count";
          countSpan.textContent = count;

          el.appendChild(nameSpan);
          el.appendChild(countSpan);

          el.addEventListener("click", () => selectPlaylist(id));
          return el;
        }

        // ── Select Playlist ──
        function selectPlaylist(id) {
          navHistory = [];
          showPlaylist(id);
        }

        function showPlaylist(id) {
          activeId = id;
          isDetailView = false;
          catalogMode = null;
          $backBtn.style.display = "none";

          // Update sidebar active state
          document.querySelectorAll(".sidebar-item").forEach((el) => {
            el.classList.toggle("active", el.dataset.id === id);
          });

          if (id === "artists") {
            showCatalogList("artists");
            return;
          }
          if (id === "albums") {
            showCatalogList("albums");
            return;
          }

          // Show track columns
          $colHeader.style.display = "";
          $trackFilter.placeholder = "filter tracks...";
          $dedupLabel.style.display = "none";
          $dedupToggle.checked = false;

          // Load tracks
          if (id === "liked") {
            $mainTitle.textContent = "Liked Songs";
            currentTracks = normalizeLibraryTracks(library.tracks);
            $mainMeta.textContent = currentTracks.length + " tracks";
          } else {
            const pl = playlists.find((p) => p.id === id);
            $mainTitle.textContent = pl.name;
            currentTracks = pl.tracks;
            $mainMeta.textContent =
              pl.trackCount + " tracks \u00b7 updated " + pl.date;
          }

          $trackFilter.value = "";
          sortCol = null;
          sortAsc = true;
          updateSortHeaders();
          filteredTracks = currentTracks.slice();
          renderTrackList();
        }

        // ── Catalog List (shared by Artists / Albums) ──
        function showCatalogList(mode) {
          catalogMode = mode;
          isDetailView = false;
          const index = mode === "artists" ? artistIndex : albumIndex;
          const label = mode === "artists" ? "Artists" : "Albums";

          $mainTitle.textContent = label;
          $mainMeta.textContent = index.length + " " + label.toLowerCase();
          $colHeader.style.display = "none";
          $trackFilter.value = "";
          $trackFilter.placeholder = "filter " + label.toLowerCase() + "...";
          $dedupLabel.style.display = "none";
          $dedupToggle.checked = false;

          catalogItems = index;
          filteredCatalog = index.slice();
          currentTracks = [];
          filteredTracks = [];
          renderCatalogList();
        }

        function renderCatalogList() {
          const total = filteredCatalog.length;
          $emptyState.style.display = total === 0 ? "" : "none";
          $emptyState.textContent = "No matches";
          $viewport.style.display = total === 0 ? "none" : "";

          $runway.style.height = total * ROW_H + "px";

          visibleRows.forEach((r) => r.el.remove());
          visibleRows = [];
          lastScrollTop = -1;
          $viewport.scrollTop = 0;
          renderVisibleCatalogRows();
        }

        function renderVisibleCatalogRows() {
          const scrollTop = $viewport.scrollTop;
          const viewH = $viewport.clientHeight;
          const total = filteredCatalog.length;

          const startIdx = Math.max(
            0,
            Math.floor(scrollTop / ROW_H) - RENDER_BUFFER,
          );
          const endIdx = Math.min(
            total,
            Math.ceil((scrollTop + viewH) / ROW_H) + RENDER_BUFFER,
          );

          const needed = new Set();
          for (let i = startIdx; i < endIdx; i++) needed.add(i);

          visibleRows = visibleRows.filter((r) => {
            if (needed.has(r.idx)) {
              needed.delete(r.idx);
              return true;
            }
            r.el.remove();
            return false;
          });

          const isAlbumCatalog = catalogMode === "albums";

          for (const idx of needed) {
            const item = filteredCatalog[idx];
            const row = document.createElement("div");
            row.className = "track-row";
            row.style.top = idx * ROW_H + "px";
            row.style.cursor = "pointer";

            const numSpan = document.createElement("span");
            numSpan.className = "col-num";
            numSpan.textContent = idx + 1;

            const nameSpan = document.createElement("span");
            nameSpan.className = "col-track";
            nameSpan.textContent = item.name;
            nameSpan.style.color = "var(--text-bright)";

            row.appendChild(numSpan);
            row.appendChild(nameSpan);

            if (isAlbumCatalog) {
              const artistSpan = document.createElement("span");
              artistSpan.className = "col-artist";
              artistSpan.textContent = item.artist;
              artistSpan.style.cursor = "default";
              row.appendChild(artistSpan);
            }

            const countSpan = document.createElement("span");
            countSpan.className = "col-date";
            countSpan.style.display = "";
            countSpan.textContent = item.count + " tracks";

            row.appendChild(countSpan);

            row.addEventListener("click", () => {
              navHistory.push({ type: "catalog", mode: catalogMode });
              if (isAlbumCatalog) {
                showAlbum(item.name, item.artist);
              } else {
                showArtist(item.name);
              }
            });

            $runway.appendChild(row);
            visibleRows.push({ idx, el: row });
          }
        }

        // ── Detail Views (Artist / Album) ──
        function showDetailView(title, meta, tracks) {
          document
            .querySelectorAll(".sidebar-item")
            .forEach((el) => el.classList.remove("active"));
          isDetailView = true;
          catalogMode = null;
          $backBtn.style.display = "block";
          $colHeader.style.display = "";
          $trackFilter.placeholder = "filter tracks...";
          $dedupLabel.style.display = "flex";
          $dedupToggle.checked = false;
          $mainTitle.textContent = title;
          $mainMeta.textContent = meta;

          $trackFilter.value = "";
          sortCol = null;
          sortAsc = true;
          updateSortHeaders();
          currentTracks = tracks;
          filteredTracks = tracks.slice();
          renderTrackList();
        }

        function showArtist(artistName) {
          const key = artistName.toLowerCase();
          const tracks = [];

          for (const t of library.tracks) {
            if (t.artist.toLowerCase() === key) {
              tracks.push({
                name: t.track,
                artist: t.artist,
                album: t.album,
                uri: t.uri,
                date: "",
                local: false,
                source: "Liked Songs",
              });
            }
          }
          for (const pl of playlists) {
            for (const t of pl.tracks) {
              if (t.artist.toLowerCase() === key) {
                tracks.push({ ...t, source: pl.name });
              }
            }
          }

          showDetailView(
            artistName,
            tracks.length + " tracks across your library",
            tracks,
          );
        }

        function showAlbum(albumName, artistName) {
          const keyAlbum = albumName.toLowerCase();
          const keyArtist = artistName.toLowerCase();
          const tracks = [];

          for (const t of library.tracks) {
            if (
              t.album.toLowerCase() === keyAlbum &&
              t.artist.toLowerCase() === keyArtist
            ) {
              tracks.push({
                name: t.track,
                artist: t.artist,
                album: t.album,
                uri: t.uri,
                date: "",
                local: false,
                source: "Liked Songs",
              });
            }
          }
          for (const pl of playlists) {
            for (const t of pl.tracks) {
              if (
                t.album.toLowerCase() === keyAlbum &&
                t.artist.toLowerCase() === keyArtist
              ) {
                tracks.push({ ...t, source: pl.name });
              }
            }
          }

          showDetailView(
            albumName + " \u2014 " + artistName,
            tracks.length + " tracks across your library",
            tracks,
          );
        }

        // ── Back Navigation ──
        $backBtn.addEventListener("click", () => {
          const prev = navHistory.pop();
          if (!prev) return;
          if (prev.type === "catalog") {
            activeId = prev.mode;
            document.querySelectorAll(".sidebar-item").forEach((el) => {
              el.classList.toggle("active", el.dataset.id === prev.mode);
            });
            $backBtn.style.display = "none";
            showCatalogList(prev.mode);
          } else if (prev.type === "playlist") {
            showPlaylist(prev.id);
          }
        });

        // ── Track Filtering ──
        function refilter() {
          const q = $trackFilter.value.toLowerCase();

          if (catalogMode) {
            filteredCatalog = q
              ? catalogItems.filter(
                  (item) =>
                    item.name.toLowerCase().includes(q) ||
                    (item.artist && item.artist.toLowerCase().includes(q)),
                )
              : catalogItems.slice();
            renderCatalogList();
            return;
          }

          if (!q) {
            filteredTracks = currentTracks.slice();
          } else {
            filteredTracks = currentTracks.filter(
              (t) =>
                t.name.toLowerCase().includes(q) ||
                t.artist.toLowerCase().includes(q) ||
                t.album.toLowerCase().includes(q),
            );
          }
          applyDedup();
          applySort();
          renderTrackList();
        }

        $trackFilter.addEventListener("input", () => {
          clearTimeout(filterTimer);
          filterTimer = setTimeout(refilter, 120);
        });

        // ── Deduplication ──
        function applyDedup() {
          if (!$dedupToggle.checked) return;
          const seen = new Set();
          filteredTracks = filteredTracks.filter((t) => {
            const key = t.uri || (t.name + "|||" + t.artist).toLowerCase();
            if (seen.has(key)) return false;
            seen.add(key);
            return true;
          });
        }

        $dedupToggle.addEventListener("change", () => {
          refilter();
        });

        // ── Sorting ──
        function applySort() {
          if (!sortCol) return;
          const dir = sortAsc ? 1 : -1;
          filteredTracks.sort((a, b) => {
            const av = (a[sortCol] || "").toLowerCase();
            const bv = (b[sortCol] || "").toLowerCase();
            return av < bv ? -dir : av > bv ? dir : 0;
          });
        }

        function toggleSort(col) {
          if (sortCol === col) {
            sortAsc = !sortAsc;
          } else {
            sortCol = col;
            sortAsc = true;
          }
          updateSortHeaders();
          applySort();
          renderTrackList();
        }

        function updateSortHeaders() {
          const map = {
            name: ".col-track",
            artist: ".col-artist",
            album: ".col-album",
            source: ".col-source",
            date: ".col-date",
          };
          $colHeader.querySelectorAll("span").forEach((s) => {
            s.classList.remove("sorted", "desc");
          });
          if (sortCol && map[sortCol]) {
            const el = $colHeader.querySelector(map[sortCol]);
            el.classList.add("sorted");
            if (!sortAsc) el.classList.add("desc");
          }
        }

        $colHeader
          .querySelector(".col-track")
          .addEventListener("click", () => toggleSort("name"));
        $colHeader
          .querySelector(".col-artist")
          .addEventListener("click", () => toggleSort("artist"));
        $colHeader
          .querySelector(".col-album")
          .addEventListener("click", () => toggleSort("album"));
        $colHeader
          .querySelector(".col-source")
          .addEventListener("click", () => toggleSort("source"));
        $colHeader
          .querySelector(".col-date")
          .addEventListener("click", () => toggleSort("date"));

        // ── Virtual Scroll Track Rendering ──
        let lastScrollTop = -1;
        let visibleRows = [];

        function renderTrackList() {
          const total = filteredTracks.length;

          if (total === 0 && currentTracks.length > 0) {
            $emptyState.textContent = "No matching tracks";
            $emptyState.style.display = "";
            $viewport.style.display = "none";
            $colHeader.style.display = "none";
            return;
          }
          if (total === 0) {
            $emptyState.textContent = "No tracks";
            $emptyState.style.display = "";
            $viewport.style.display = "none";
            $colHeader.style.display = "none";
            return;
          }

          $emptyState.style.display = "none";
          $viewport.style.display = "";
          $colHeader.style.display = "";

          // Update column visibility
          const hasDate = filteredTracks.some((t) => t.date);
          $colHeader.querySelector(".col-date").style.display = hasDate
            ? ""
            : "none";
          $colHeader.querySelector(".col-source").style.display = isDetailView
            ? ""
            : "none";

          $runway.style.height = total * ROW_H + "px";

          // Clear existing
          visibleRows.forEach((r) => r.el.remove());
          visibleRows = [];
          lastScrollTop = -1;

          $viewport.scrollTop = 0;
          renderVisibleRows();
        }

        function renderVisibleRows() {
          const scrollTop = $viewport.scrollTop;
          const viewH = $viewport.clientHeight;
          const total = filteredTracks.length;

          const startIdx = Math.max(
            0,
            Math.floor(scrollTop / ROW_H) - RENDER_BUFFER,
          );
          const endIdx = Math.min(
            total,
            Math.ceil((scrollTop + viewH) / ROW_H) + RENDER_BUFFER,
          );

          // Determine which rows we need
          const needed = new Set();
          for (let i = startIdx; i < endIdx; i++) needed.add(i);

          // Remove rows no longer needed
          visibleRows = visibleRows.filter((r) => {
            if (needed.has(r.idx)) {
              needed.delete(r.idx);
              return true;
            }
            r.el.remove();
            return false;
          });

          const hasDate = filteredTracks.some((t) => t.date);

          // Add new rows
          for (const idx of needed) {
            const t = filteredTracks[idx];
            const row = document.createElement("div");
            row.className = "track-row";
            row.style.top = idx * ROW_H + "px";

            const numSpan = document.createElement("span");
            numSpan.className = "col-num";
            numSpan.textContent = idx + 1;

            const trackSpan = document.createElement("span");
            trackSpan.className = "col-track";

            if (t.uri && !t.local) {
              const a = document.createElement("a");
              const trackId = t.uri.split(":").pop();
              const type = t.isAlbum ? "album" : "track";
              a.href = "https://open.spotify.com/" + type + "/" + trackId;
              a.target = "_blank";
              a.rel = "noopener";
              a.textContent = t.name;
              trackSpan.appendChild(a);
            } else {
              const span = document.createElement("span");
              span.className = t.local ? "local-track" : "";
              span.textContent = t.name;
              trackSpan.appendChild(span);
            }

            const artistSpan = document.createElement("span");
            artistSpan.className = "col-artist";
            artistSpan.textContent = t.artist;
            artistSpan.addEventListener("click", () => {
              if (activeId) navHistory.push({ type: "playlist", id: activeId });
              showArtist(t.artist);
            });

            const albumSpan = document.createElement("span");
            albumSpan.className = "col-album";
            albumSpan.textContent = t.album;
            if (t.album) {
              albumSpan.addEventListener("click", () => {
                if (activeId)
                  navHistory.push({ type: "playlist", id: activeId });
                showAlbum(t.album, t.artist);
              });
            }

            const sourceSpan = document.createElement("span");
            sourceSpan.className = "col-source";
            sourceSpan.textContent = t.source || "";
            sourceSpan.style.display = isDetailView ? "" : "none";

            const dateSpan = document.createElement("span");
            dateSpan.className = "col-date";
            dateSpan.textContent = t.date || "";
            dateSpan.style.display = hasDate ? "" : "none";

            row.appendChild(numSpan);
            row.appendChild(trackSpan);
            row.appendChild(artistSpan);
            row.appendChild(albumSpan);
            row.appendChild(sourceSpan);
            row.appendChild(dateSpan);

            $runway.appendChild(row);
            visibleRows.push({ idx, el: row });
          }
        }

        $viewport.addEventListener("scroll", () => {
          requestAnimationFrame(() => {
            if (catalogMode) renderVisibleCatalogRows();
            else renderVisibleRows();
          });
        });

        // ── Sidebar Search ──
        $sidebarSearch.addEventListener("input", () => {
          renderSidebar($sidebarSearch.value);
        });

        // ── Keyboard shortcuts ──
        document.addEventListener("keydown", (e) => {
          // Cmd/Ctrl+K focuses sidebar search
          if ((e.metaKey || e.ctrlKey) && e.key === "k") {
            e.preventDefault();
            $sidebarSearch.focus();
            $sidebarSearch.select();
          }
          // Cmd/Ctrl+F focuses track filter
          if ((e.metaKey || e.ctrlKey) && e.key === "f") {
            e.preventDefault();
            $trackFilter.focus();
            $trackFilter.select();
          }
          // Escape clears focused input
          if (e.key === "Escape") {
            if (document.activeElement === $sidebarSearch) {
              $sidebarSearch.value = "";
              $sidebarSearch.blur();
              renderSidebar("");
            } else if (document.activeElement === $trackFilter) {
              $trackFilter.value = "";
              $trackFilter.blur();
              filteredTracks = currentTracks;
              renderTrackList();
            }
          }
        });

        // ── Init ──
        tryLocalData();
      })();
    </script>
  </body>
</html>
